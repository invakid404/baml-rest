package introspected

import "{{ .streamPackagePath }}"
{{- if .hasTypeBuilder }}
import "{{ .typeBuilderPackagePath }}"
{{- end }}

var Stream = {{ .streamPackageName }}.Stream

var StreamMethods = map[string][]string{
{{ range .streamMethods }}
  {{ .name | printf "%q" }}: []string{ {{ quoteAndJoin .args }} },
{{ end }}
}

// SyncMethods maps sync function names to their argument names
var SyncMethods = map[string][]string{
{{ range .syncMethods }}
  {{ .name | printf "%q" }}: []string{ {{ quoteAndJoin .args }} },
{{ end }}
}

// SyncFuncs maps sync function names to their function values (for reflection)
var SyncFuncs = map[string]any{
{{ range .syncMethods }}
  {{ .name | printf "%q" }}: {{ $.streamPackageName }}.{{ .name }},
{{ end }}
}

// Parse is the parse API for parsing raw LLM responses into final types
var Parse = {{ .streamPackageName }}.Parse

// ParseMethods is a set of method names available on Parse
var ParseMethods = map[string]struct{}{
{{ range .parseMethods }}
  {{ . | printf "%q" }}: {},
{{ end }}
}

// ParseStream is the parse_stream API for parsing raw LLM responses into partial/stream types
var ParseStream = {{ .streamPackageName }}.ParseStream

// ParseStreamMethods is a set of method names available on ParseStream
var ParseStreamMethods = map[string]struct{}{
{{ range .parseStreamMethods }}
  {{ . | printf "%q" }}: {},
{{ end }}
}

// ParseStreamFuncs maps ParseStream method names to their function values (for reflection)
var ParseStreamFuncs = map[string]any{
{{ range .parseStreamMethods }}
  {{ . | printf "%q" }}: {{ $.streamPackageName }}.ParseStream.{{ . }},
{{ end }}
}

{{- if .hasTypeBuilder }}

// TypeBuilder is the generated TypeBuilder type
type TypeBuilder = type_builder.TypeBuilder

// ClassBuilder is the interface for dynamic classes
type ClassBuilder = type_builder.ClassBuilder

// EnumBuilder is the interface for dynamic enums
type EnumBuilder = type_builder.EnumBuilder

// ClassView is the interface for static classes
type ClassView = type_builder.ClassView

// EnumView is the interface for static enums
type EnumView = type_builder.EnumView

// Type is the BAML type
type Type = type_builder.Type

// NewTypeBuilder creates a new TypeBuilder using the BAML runtime's factory
var NewTypeBuilder = {{ .streamPackageName }}.NewTypeBuilder

// DynamicClassAccessor is a function that returns a ClassBuilder for a dynamic class
type DynamicClassAccessor func(*TypeBuilder) (ClassBuilder, error)

// DynamicEnumAccessor is a function that returns an EnumBuilder for a dynamic enum
type DynamicEnumAccessor func(*TypeBuilder) (EnumBuilder, error)

// StaticClassAccessor is a function that returns a ClassView for a static class
type StaticClassAccessor func(*TypeBuilder) (ClassView, error)

// StaticEnumAccessor is a function that returns an EnumView for a static enum
type StaticEnumAccessor func(*TypeBuilder) (EnumView, error)

// DynamicClasses maps dynamic class names to their accessor functions
var DynamicClasses = map[string]DynamicClassAccessor{
{{- range .dynamicClasses }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (ClassBuilder, error) { return tb.{{ .Name }}() },
{{- end }}
}

// StaticClasses maps static class names to their accessor functions
var StaticClasses = map[string]StaticClassAccessor{
{{- range .staticClasses }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (ClassView, error) { return tb.{{ .Name }}() },
{{- end }}
}

// DynamicEnums maps dynamic enum names to their accessor functions
var DynamicEnums = map[string]DynamicEnumAccessor{
{{- range .dynamicEnums }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (EnumBuilder, error) { return tb.{{ .Name }}() },
{{- end }}
}

// StaticEnums maps static enum names to their accessor functions
var StaticEnums = map[string]StaticEnumAccessor{
{{- range .staticEnums }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (EnumView, error) { return tb.{{ .Name }}() },
{{- end }}
}

// AllClasses returns all known class names (both dynamic and static)
func AllClasses() []string {
  result := make([]string, 0, len(DynamicClasses) + len(StaticClasses))
  for name := range DynamicClasses {
    result = append(result, name)
  }
  for name := range StaticClasses {
    result = append(result, name)
  }
  return result
}

// AllEnums returns all known enum names (both dynamic and static)
func AllEnums() []string {
  result := make([]string, 0, len(DynamicEnums) + len(StaticEnums))
  for name := range DynamicEnums {
    result = append(result, name)
  }
  for name := range StaticEnums {
    result = append(result, name)
  }
  return result
}

// IsDynamicClass returns true if the class exists and is dynamic
func IsDynamicClass(name string) bool {
  _, ok := DynamicClasses[name]
  return ok
}

// IsDynamicEnum returns true if the enum exists and is dynamic
func IsDynamicEnum(name string) bool {
  _, ok := DynamicEnums[name]
  return ok
}

// ClassExists returns true if a class with this name exists (dynamic or static)
func ClassExists(name string) bool {
  _, dynamic := DynamicClasses[name]
  _, static := StaticClasses[name]
  return dynamic || static
}

// EnumExists returns true if an enum with this name exists (dynamic or static)
func EnumExists(name string) bool {
  _, dynamic := DynamicEnums[name]
  _, static := StaticEnums[name]
  return dynamic || static
}

// GetClassType returns the Type for a class by name
func GetClassType(tb *TypeBuilder, name string) (Type, error) {
  if accessor, ok := DynamicClasses[name]; ok {
    builder, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return builder.Type()
  }
  if accessor, ok := StaticClasses[name]; ok {
    view, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return view.Type()
  }
  return nil, nil
}

// GetEnumType returns the Type for an enum by name
func GetEnumType(tb *TypeBuilder, name string) (Type, error) {
  if accessor, ok := DynamicEnums[name]; ok {
    builder, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return builder.Type()
  }
  if accessor, ok := StaticEnums[name]; ok {
    view, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return view.Type()
  }
  return nil, nil
}
{{- end }}