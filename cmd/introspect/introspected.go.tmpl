package introspected

import "{{ .streamPackagePath }}"
{{- if .hasTypeBuilder }}
import "{{ .typeBuilderPackagePath }}"
{{- end }}

var Stream = {{ .streamPackageName }}.Stream

var StreamMethods = map[string][]string{
{{ range .streamMethods }}
  {{ .name | printf "%q" }}: []string{ {{ quoteAndJoin .args }} },
{{ end }}
}

// SyncMethods maps sync function names to their argument names
var SyncMethods = map[string][]string{
{{ range .syncMethods }}
  {{ .name | printf "%q" }}: []string{ {{ quoteAndJoin .args }} },
{{ end }}
}

// SyncFuncs maps sync function names to their function values (for reflection)
var SyncFuncs = map[string]any{
{{ range .syncMethods }}
  {{ .name | printf "%q" }}: {{ $.streamPackageName }}.{{ .name }},
{{ end }}
}

// Parse is the parse API for parsing raw LLM responses into final types
var Parse = {{ .streamPackageName }}.Parse

// ParseMethods is a set of method names available on Parse
var ParseMethods = map[string]struct{}{
{{ range .parseMethods }}
  {{ . | printf "%q" }}: {},
{{ end }}
}

// ParseStream is the parse_stream API for parsing raw LLM responses into partial/stream types
var ParseStream = {{ .streamPackageName }}.ParseStream

// ParseStreamMethods is a set of method names available on ParseStream
var ParseStreamMethods = map[string]struct{}{
{{ range .parseStreamMethods }}
  {{ . | printf "%q" }}: {},
{{ end }}
}

// ParseStreamFuncs maps ParseStream method names to their function values (for reflection)
var ParseStreamFuncs = map[string]any{
{{ range .parseStreamMethods }}
  {{ . | printf "%q" }}: {{ $.streamPackageName }}.ParseStream.{{ . }},
{{ end }}
}

{{- if .hasTypeBuilder }}

// TypeBuilder is the generated TypeBuilder type
type TypeBuilder = type_builder.TypeBuilder

// Type is the BAML type
type Type = type_builder.Type

// ClassPropertyBuilder is the interface for class property builders
type ClassPropertyBuilder = type_builder.ClassPropertyBuilder

// EnumValueBuilder is the interface for enum value builders
type EnumValueBuilder = type_builder.EnumValueBuilder

// NewTypeBuilder creates a new TypeBuilder using the BAML runtime's factory
var NewTypeBuilder = {{ .streamPackageName }}.NewTypeBuilder

// DynamicClasses maps dynamic class names to their accessor functions
var DynamicClasses = map[string]DynamicClassAccessor{
{{- range .dynamicClasses }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (DynamicClassBuilder, error) { return tb.{{ .Name }}() },
{{- end }}
}

// StaticClasses maps static class names to their accessor functions
var StaticClasses = map[string]StaticClassAccessor{
{{- range .staticClasses }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (Typed, error) { return tb.{{ .Name }}() },
{{- end }}
}

// DynamicEnums maps dynamic enum names to their accessor functions
var DynamicEnums = map[string]DynamicEnumAccessor{
{{- range .dynamicEnums }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (DynamicEnumBuilder, error) { return tb.{{ .Name }}() },
{{- end }}
}

// StaticEnums maps static enum names to their accessor functions
var StaticEnums = map[string]StaticEnumAccessor{
{{- range .staticEnums }}
  {{ .TypeName | printf "%q" }}: func(tb *TypeBuilder) (Typed, error) { return tb.{{ .Name }}() },
{{- end }}
}

// AllClasses returns all known class names (both dynamic and static)
func AllClasses() []string {
  result := make([]string, 0, len(DynamicClasses) + len(StaticClasses))
  for name := range DynamicClasses {
    result = append(result, name)
  }
  for name := range StaticClasses {
    result = append(result, name)
  }
  return result
}

// AllEnums returns all known enum names (both dynamic and static)
func AllEnums() []string {
  result := make([]string, 0, len(DynamicEnums) + len(StaticEnums))
  for name := range DynamicEnums {
    result = append(result, name)
  }
  for name := range StaticEnums {
    result = append(result, name)
  }
  return result
}

// IsDynamicClass returns true if the class exists and is dynamic
func IsDynamicClass(name string) bool {
  _, ok := DynamicClasses[name]
  return ok
}

// IsDynamicEnum returns true if the enum exists and is dynamic
func IsDynamicEnum(name string) bool {
  _, ok := DynamicEnums[name]
  return ok
}

// ClassExists returns true if a class with this name exists (dynamic or static)
func ClassExists(name string) bool {
  _, dynamic := DynamicClasses[name]
  _, static := StaticClasses[name]
  return dynamic || static
}

// EnumExists returns true if an enum with this name exists (dynamic or static)
func EnumExists(name string) bool {
  _, dynamic := DynamicEnums[name]
  _, static := StaticEnums[name]
  return dynamic || static
}

// GetClassType returns the Type for a class by name
func GetClassType(tb *TypeBuilder, name string) (Type, error) {
  if accessor, ok := DynamicClasses[name]; ok {
    builder, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return builder.Type()
  }
  if accessor, ok := StaticClasses[name]; ok {
    view, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return view.Type()
  }
  return nil, nil
}

// GetEnumType returns the Type for an enum by name
func GetEnumType(tb *TypeBuilder, name string) (Type, error) {
  if accessor, ok := DynamicEnums[name]; ok {
    builder, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return builder.Type()
  }
  if accessor, ok := StaticEnums[name]; ok {
    view, err := accessor(tb)
    if err != nil {
      return nil, err
    }
    return view.Type()
  }
  return nil, nil
}
{{- end }}